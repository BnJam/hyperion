{
  "metadata": {
    "intent": "Advance Hyperion's deterministic cast protocol by hardening queue telemetry, formalizing payload validation, bridging issue-to-merge flows, and documenting the RATATUI observability/governance story.",
    "goals": [
      "Instrument SqliteQueue leases, WAL telemetry, and Doctor diagnostics so cast health is visible and self-healing.",
      "Define a CastPayload schema plus validation hooks so every request includes approvals, TTLs, and guard outputs before hitting the queue.",
      "Build the issue-to-merge bridge, RATATUI telemetry dashboards, and governance docs so operators trust and audit every cast lifecycle."
    ],
    "non_goals": [
      "Add new database backends beyond SQLite/WAL.",
      "Bypass human approvals for merge slots.",
      "Introduce a separate GUI beyond the existing CLI/TUI surfaces."
    ],
    "scope": [
      "Hyperion's queue wiring, change request schema, issue bridge, telemetry/doctor guard rails, and CLI/TUI surfaces.",
      "Cross-repo learnings from technocore queue resiliency plus Farcaster's cast/merge documentation and guards."
    ],
    "constraints": [
      "Every cast must map to a deterministic JSON payload whose audit tokens, WAL anchors, and guard outputs are stored before enqueueing.",
      "Guard suites (cargo fmt/clippy/test stack plus the documented checks) must run before any merge or cast approval is recorded.",
      "Operators must continue seeing human approvals, telemetry, and logs inside the CLI/TUI so no cast bypasses observability."
    ],
    "approval_pattern": "^Approved:[[:space:]]+yes$",
    "required_sections": "Intent,Goals,Non-Goals,Scope,Constraints,Plan,Commands,Validation,Approval",
    "validation_policy": "Guard scripts + deterministic cast/messaging audits",
    "validation_steps": [
      "../developer/scripts/validate-plan.sh --plan ./WORKPLAN.md --required \"Intent,Goals,Non-Goals,Scope,Constraints,Plan,Commands,Validation,Approval\" --approval-pattern \"^Approved:[[:space:]]+yes$\"",
      "../developer/scripts/check-workspace.sh --root . --fail-on-dirty",
      "../developer/scripts/check-anti-patterns.sh --plan ./WORKPLAN.md --root .",
      "../developer/scripts/librarian-discovery.sh --workspace . --db /Users/bsmith/thelibrary/hyperion-be573d94/librarian.db --plan WORKPLAN.md"
    ],
    "commands": [
      "cargo fmt --check",
      "cargo clippy --workspace --all-targets --all-features",
      "cargo test --workspace",
      "cargo build",
      "cargo run -- --help"
    ],
    "approval": {
      "Approved": "yes",
      "Approved by": "bsmith",
      "Approved on": "2026-01-28"
    }
  },
  "phases": [
    {
      "name": "Phase 0 — Queue Telemetry & Lease Hardening",
      "summary": "Make leases, TTLs, dedup windows, and Doctor telemetry actionable so casts never linger unnoticed.",
      "tasks": [
        {
          "id": "T001",
          "summary": "Audit SqliteQueue leases, dedupe, and Doctor instrumentation.",
          "description": "Review queue/doctor sources, codify TTL/lease recovery rules, and add WAL audit points so lease histories stay observable.",
          "commands": [
            "rg -n \"leased_until\" src/queue.rs",
            "rg -n \"DEFAULT_DEDUP_WINDOW\" hyperion/src/doctor.rs",
            "rg -n \"QueueMetrics\" hyperion/src/models.rs"
          ],
          "verification": [
            "cargo fmt --check",
            "rg -n \"lease\" hyperion/HYPERION.md"
          ]
        },
        {
          "id": "T002",
          "summary": "Add a lease reclamation watchdog tied to WAL logs.",
          "description": "Implement or document a watcher that scans change_queue for expired leases, reclaims them, and logs the events as ChangeQueueLog entries for easier triaging.",
          "commands": [
            "rg -n \"watcher\" src",
            "cat hyperion/src/watcher.rs"
          ],
          "verification": [
            "rg -n \"lease reclaim\" hyperion/execution/command_logs/command_*"
          ]
        }
      ]
    },
    {
      "name": "Phase 1 — Cast Schema & Validation",
      "summary": "Ensure every cast payload carries structured headers, approvals, and guard outputs before the queue touches it.",
      "tasks": [
        {
          "id": "T101",
          "summary": "Define the CastPayload schema and propagate it through models/requests.",
          "description": "Add a typed CastPayload (task_id, agent_id, approvals, TTL, telemetry anchors, guard command outputs) in models.rs and ensure request types/serializers reflect it.",
          "commands": [
            "cat hyperion/src/models.rs",
            "cat hyperion/src/request.rs"
          ],
          "verification": [
            "rg -n \"CastPayload\" hyperion/src",
            "rg -n \"Cast\" hyperion/SCHEMAS.md"
          ]
        },
        {
          "id": "T102",
          "summary": "Enforce payload version/TTL/checksum during validation/enqueue.",
          "description": "Extend validator.rs (or doctor.rs) to assert payload version, TTL, and checksum, then call those checks inside SqliteQueue::enqueue so only audited payloads enter the queue.",
          "commands": [
            "rg -n \"validator\" hyperion/src",
            "rg -n \"enqueue\" hyperion/src/queue.rs"
          ],
          "verification": [
            "cargo test --workspace",
            "rg -n \"validator payload\" hyperion/execution/command_logs/command_*"
          ]
        }
      ]
    },
    {
      "name": "Phase 2 — Issue → Merge Cast Flow",
      "summary": "Ingest Farcaster-style casts, track guard outputs, and buffer them in a merge queue that waits for approvals + CI.",
      "tasks": [
        {
          "id": "T201",
          "summary": "Build the issue bridge that enqueues casts with guard metadata.",
          "description": "Wire orchestrator.rs/runner.rs to process Farcaster-style casts, record guard commands/approvals, and enqueue them while preserving the metadata.",
          "commands": [
            "cat hyperion/src/orchestrator.rs",
            "rg -n \"issue\" hyperion/src/runner.rs"
          ],
          "verification": [
            "rg -n \"merge queue\" hyperion/src",
            "rg -n \"issue bridge\" hyperion/HARDENING.md"
          ]
        },
        {
          "id": "T202",
          "summary": "Implement a merge queue buffer + release stub tied to guard suites.",
          "description": "Add a buffer in exporter.rs/runner.rs that holds casts until cargo fmt/clippy/test pass plus human approval, logging CI outputs inside ChangeQueueLog for auditability.",
          "commands": [
            "rg -n \"export\" hyperion/src",
            "rg -n \"cargo fmt\" hyperion/execution/commands_from_plan.txt"
          ],
          "verification": [
            "rg -n \"guard run\" hyperion/execution/exit_codes.json"
          ]
        }
      ]
    },
    {
      "name": "Phase 3 — RATATUI Visibility & Observability",
      "summary": "Surface queue/guard telemetry inside the TUI and emit structured reports for dashboards.",
      "tasks": [
        {
          "id": "T301",
          "summary": "Surface queue metrics + guard history in the RATATUI panels.",
          "description": "Update tui.rs/fs_watch.rs to display queue depth, cast latency, WAL progress, guard command results, approvals, and ChangeQueueLog insights.",
          "commands": [
            "rg -n \"ratatui\" hyperion/src",
            "cat hyperion/src/tui.rs"
          ],
          "verification": [
            "echo 'TUI snapshot references cast latency, queue depth, guard outcomes'"
          ]
        },
        {
          "id": "T302",
          "summary": "Emit structured telemetry per run for dashboards to trend.",
          "description": "Write queue depth, WAL checkpoint stats, dedup hits, and guard results into execution/verification_report.json on every run so dashboards ingest deterministic telemetry.",
          "commands": [
            "cat hyperion/src/exporter.rs",
            "rg -n \"verification_report\" execution"
          ],
          "verification": [
            "rg -n \"queue depth\" hyperion/execution/verification_report.json"
          ]
        }
      ]
    },
    {
      "name": "Phase 4 — Testing, Governance & Playbooks",
      "summary": "Create cast replay fixtures, capture WAL audits, and document governance playbooks for operators.",
      "tasks": [
        {
          "id": "T401",
          "summary": "Expand CI/tests with cast replay fixtures and WAL audits.",
          "description": "Export sample payloads from request/models, build fixtures that replay casts, and verify WAL retention plus guard logging during cargo test runs.",
          "commands": [
            "cat hyperion/src/request.rs",
            "cat hyperion/src/models.rs"
          ],
          "verification": [
            "cargo test --workspace",
            "rg -n \"cast fixture\" hyperion/tests"
          ]
        },
        {
          "id": "T402",
          "summary": "Update docs/playbooks to explain the deterministic cast lifecycle.",
          "description": "Refresh README.md, HYPERION.md, references/ASI_FRAMEWORK.md, and references/QUESTIONS.md with the issue bridge story, guard requirements, telemetry expectations, and lingering decisions.",
          "commands": [
            "cat hyperion/README.md",
            "rg -n \"cast\" hyperion/references/QUESTIONS.md"
          ],
          "verification": [
            "rg -n \"deterministic\" hyperion/references/QUESTIONS.md",
            "rg -n \"cast work\" hyperion/HYPERION.md"
          ]
        }
      ]
    }
  ]
}
