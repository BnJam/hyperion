{
  "plan_definition": "plans/phase_plan.json",
  "plan_path": "/Users/bsmith/bnjam/hyperion/WORKPLAN.md",
  "phase_index": -1,
  "task_index": -1,
  "phases": [
    {
      "name": "Phase 0 \u2014 Queue Telemetry & Lease Hardening",
      "summary": "Make leases, TTLs, dedup windows, and Doctor telemetry actionable so casts never linger unnoticed.",
      "tasks": [
        {
          "id": "T001",
          "summary": "Audit SqliteQueue leases, dedupe, and Doctor instrumentation.",
          "description": "Review queue/doctor sources, codify TTL/lease recovery rules, and add WAL audit points so lease histories stay observable.",
          "commands": [
            "rg -n \"leased_until\" src/queue.rs",
            "rg -n \"DEFAULT_DEDUP_WINDOW\" hyperion/src/doctor.rs",
            "rg -n \"QueueMetrics\" hyperion/src/models.rs"
          ],
          "verification": [
            "cargo fmt --check",
            "rg -n \"lease\" hyperion/HYPERION.md"
          ],
          "status": "completed"
        },
        {
          "id": "T002",
          "summary": "Add a lease reclamation watchdog tied to WAL logs.",
          "description": "Implement or document a watcher that scans change_queue for expired leases, reclaims them, and logs the events as ChangeQueueLog entries for easier triaging.",
          "commands": [
            "rg -n \"watcher\" src",
            "cat hyperion/src/watcher.rs"
          ],
          "verification": [
            "rg -n \"lease reclaim\" hyperion/execution/command_logs/command_*"
          ],
          "status": "completed"
        }
      ]
    },
    {
      "name": "Phase 1 \u2014 Cast Schema & Validation",
      "summary": "Ensure every cast payload carries structured headers, approvals, and guard outputs before the queue touches it.",
      "tasks": [
        {
          "id": "T101",
          "summary": "Define the CastPayload schema and propagate it through models/requests.",
          "description": "Add a typed CastPayload (task_id, agent_id, approvals, TTL, telemetry anchors, guard command outputs) in models.rs and ensure request types/serializers reflect it.",
          "commands": [
            "cat hyperion/src/models.rs",
            "cat hyperion/src/request.rs"
          ],
          "verification": [
            "rg -n \"CastPayload\" hyperion/src",
            "rg -n \"Cast\" hyperion/SCHEMAS.md"
          ],
          "status": "completed"
        },
        {
          "id": "T102",
          "summary": "Enforce payload version/TTL/checksum during validation/enqueue.",
          "description": "Extend validator.rs (or doctor.rs) to assert payload version, TTL, and checksum, then call those checks inside SqliteQueue::enqueue so only audited payloads enter the queue.",
          "commands": [
            "rg -n \"validator\" hyperion/src",
            "rg -n \"enqueue\" hyperion/src/queue.rs"
          ],
          "verification": [
            "cargo test --workspace",
            "rg -n \"validator payload\" hyperion/execution/command_logs/command_*"
          ],
          "status": "completed"
        }
      ]
    },
    {
      "name": "Phase 2 \u2014 Issue \u2192 Merge Cast Flow",
      "summary": "Ingest Farcaster-style casts, track guard outputs, and buffer them in a merge queue that waits for approvals + CI.",
      "tasks": [
        {
          "id": "T201",
          "summary": "Build the issue bridge that enqueues casts with guard metadata.",
          "description": "Wire orchestrator.rs/runner.rs to process Farcaster-style casts, record guard commands/approvals, and enqueue them while preserving the metadata.",
          "commands": [
            "cat hyperion/src/orchestrator.rs",
            "rg -n \"issue\" hyperion/src/runner.rs"
          ],
          "verification": [
            "rg -n \"merge queue\" hyperion/src",
            "rg -n \"issue bridge\" hyperion/HARDENING.md"
          ],
          "status": "completed"
        },
        {
          "id": "T202",
          "summary": "Implement a merge queue buffer + release stub tied to guard suites.",
          "description": "Add a buffer in exporter.rs/runner.rs that holds casts until cargo fmt/clippy/test pass plus human approval, logging CI outputs inside ChangeQueueLog for auditability.",
          "commands": [
            "rg -n \"export\" hyperion/src",
            "rg -n \"cargo fmt\" hyperion/execution/commands_from_plan.txt"
          ],
          "verification": [
            "rg -n \"guard run\" hyperion/execution/exit_codes.json"
          ],
          "status": "completed"
        }
      ]
    },
    {
      "name": "Phase 3 \u2014 RATATUI Visibility & Observability",
      "summary": "Surface queue/guard telemetry inside the TUI and emit structured reports for dashboards.",
      "tasks": [
        {
          "id": "T301",
          "summary": "Surface queue metrics + guard history in the RATATUI panels.",
          "description": "Update tui.rs/fs_watch.rs to display queue depth, cast latency, WAL progress, guard command results, approvals, and ChangeQueueLog insights.",
          "commands": [
            "rg -n \"ratatui\" hyperion/src",
            "cat hyperion/src/tui.rs"
          ],
          "verification": [
            "echo 'TUI snapshot references cast latency, queue depth, guard outcomes'"
          ],
          "status": "completed"
        },
        {
          "id": "T302",
          "summary": "Emit structured telemetry per run for dashboards to trend.",
          "description": "Write queue depth, WAL checkpoint stats, dedup hits, and guard results into execution/verification_report.json on every run so dashboards ingest deterministic telemetry.",
          "commands": [
            "cat hyperion/src/exporter.rs",
            "rg -n \"verification_report\" execution"
          ],
          "verification": [
            "rg -n \"queue depth\" hyperion/execution/verification_report.json"
          ],
          "status": "completed"
        }
      ]
    },
    {
      "name": "Phase 4 \u2014 Testing, Governance & Playbooks",
      "summary": "Create cast replay fixtures, capture WAL audits, and document governance playbooks for operators.",
      "tasks": [
        {
          "id": "T401",
          "summary": "Expand CI/tests with cast replay fixtures and WAL audits.",
          "description": "Export sample payloads from request/models, build fixtures that replay casts, and verify WAL retention plus guard logging during cargo test runs.",
          "commands": [
            "cat hyperion/src/request.rs",
            "cat hyperion/src/models.rs"
          ],
          "verification": [
            "cargo test --workspace",
            "rg -n \"cast fixture\" hyperion/tests"
          ],
          "status": "completed"
        },
        {
          "id": "T402",
          "summary": "Update docs/playbooks to explain the deterministic cast lifecycle.",
          "description": "Refresh README.md, HYPERION.md, references/ASI_FRAMEWORK.md, and references/QUESTIONS.md with the issue bridge story, guard requirements, telemetry expectations, and lingering decisions.",
          "commands": [
            "cat hyperion/README.md",
            "rg -n \"cast\" hyperion/references/QUESTIONS.md"
          ],
          "verification": [
            "rg -n \"deterministic\" hyperion/references/QUESTIONS.md",
            "rg -n \"cast work\" hyperion/HYPERION.md"
          ],
          "status": "completed"
        }
      ]
    }
  ],
  "last_updated": {
    "phase": 4,
    "task": 1
  }
}