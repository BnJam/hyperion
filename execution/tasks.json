{
  "tasks": [
    {"id": "T001", "description": "cargo fmt --check", "status": "done"},
    {"id": "T002", "description": "cargo clippy --workspace --all-targets --all-features", "status": "done"},
    {"id": "T003", "description": "cargo test --workspace", "status": "done"},
    {"id": "T004", "description": "cargo build", "status": "done"},
    {"id": "T005", "description": "cargo run", "status": "done"},
    {"id": "T006", "description": "Captured agent context persistence by storing `Copilot` session metadata (resume hash, allow-all flag) in SQLite and reusing it via `hyperion session init` / `session list`.", "status": "done"},
    {"id": "T007", "description": "Added CLI bootstrapping (`hyperion session init --resume=<token>`) so ongoing runs can reuse pre-provisioned sessions instead of relying solely on per-request prompts.", "status": "done"},
    {"id": "T008", "description": "Added `testapp/orchestrate-request-003.json` to exercise the deterministic request path and to document the latest expectations for filesystem patches, fsnotify audits, and queue telemetry.", "status": "done"},
    {"id": "T009", "description": "Switched the worker `apply_change_request` pipeline to `diffy`-aware parallel filesystem writes, eliminating the `git apply` dependency and allowing deterministic patching via `write_modification`.", "status": "done"},
    {"id": "T010", "description": "Persisted worker telemetry (change_queue_logs) and fsnotify events (new `file_modifications` table) as JSON so the TUI can surface structured history without polluting the terminal.", "status": "done"},
    {"id": "T011", "description": "Explored how to expand the orchestrator/runtime lifetime so agents/workers persist for the duration of the binary (system lifecycle), backing state in the queue/DB and surfacing this persistence story through the CLI/TUI experience.", "status": "done"},
    {"id": "T012", "description": "Captured the runtime persistence story by wiring session data into SQLite and surfacing it in the CLI/TUI so the system lifecycle (binary execution) is the only persistence boundary.", "status": "done"},
    {"id": "T013", "description": "Added TUI controls/documentation that explain how to bootstrap and re-use Copilot sessions (including `--resume=<sessionhash>` plus `--allow-all-tools`) once the initial handshake is provisioned, clarifying that these interactions live only for the duration of the `hyperion` binary execution.", "status": "done"},
    {"id": "T014", "description": "Added `hyperion export` so operators can seed other directories with the Hyperion skill catalog, export guide, and guidance on reusing the runtime/session persistence layer.", "status": "done"},
    {"id": "T015", "description": "Reworked the ratatui dashboard into a multi-pane console that surfaces queue insights, up-to-100 task history entries, worker logs, and file modification audits sourced from the SQLite store so the screen stays clear of verbatim trace output.", "status": "done"},
    {"id": "T016", "description": "Replace the single `Mutex<Connection>` in `SqliteQueue` with per-worker (or pooled) connections, keep prepared statements warm, and limit lock spans so multiple workers can pull/dequeue/apply in parallel without contention.", "status": "done"},
    {"id": "T017", "description": "Harden the dequeue/update sequence with an explicit `BEGIN IMMEDIATE`, a selective lease filter on `(status, leased_until)` plus a composite index covering `(status, leased_until, id)`, and a `lease_owner` audit column to avoid lost leases when threads overlap.", "status": "done"},
    {"id": "T018", "description": "Surface dequeue latency, apply duration, and poll interval metrics in `change_queue_logs` and `file_modifications` so the TUI/dashboard can track throughput trends without external tracing.", "status": "done"},
    {"id": "T019", "description": "Add TTL/archival controls for `change_queue` rows and dead-letter entries as part of workload-scaling experiments, balancing faster reads for active work with bounded history retention.", "status": "done"},
    {"id": "T020", "description": "Add JSON/flags to CLI listing commands (`List`, `ListDeadLetters`, `History`, `Worker Logs`) so automation pipelines can consume structured records, while `--since`/`--limit` filters support narrower views (referencing `src/main.rs`’ simple prints).", "status": "done"},
    {"id": "T021", "description": "Add CLI/TUI guidance that explains the new filtering controls and the expected throughput ranges, surfacing the `worker_count` and new metrics streamed from the queue logs to highlight the “live queue” status.", "status": "done"},
    {"id": "T022", "description": "Strengthen `validator::validate_change_request` so it checks patch-target alignment, ensures `operation` matches the patch contents, and enforces per-change hashes/signatures before enqueueing to avoid drift (`src/validator.rs` currently only checks presence of fields).", "status": "done"},
    {"id": "T023", "description": "Harden `apply::apply_change_request` to surface deterministic failure reasons (e.g., invalid patch format, permission errors) instead of silently writing the literal patch text when `diffy::apply` fails, and capture stdout/stderr into the queue log records for postmortem clarity.", "status": "done"},
    {"id": "T024", "description": "Add unit/integration tests around `SqliteQueue` lease/mark transitions, worker retries, and CLI/TUI progress hooks plus `cargo fmt/clippy/test` automation to prove performance and safety improvements survive regression.", "status": "done"},
    {"id": "T025", "description": "Build a diagnostics command (`hyperion doctor` or `hyperion inspect-queue`) that validates schema migrations, connection health, and WAL archival state before workers start, reusing the `SqliteQueue` APIs to check indexes/TTL columns added in earlier phases.", "status": "done"},
    {"id": "T026", "description": "Document the new validation rules/checks in `SCHEMAS.md`, HARDENING.md, and README.md so contributors know what must pass before the queue applies changes.", "status": "done"},
    {"id": "T027", "description": "Add queue-side instrumentation that snapshots throughput/latency/contended-lease metrics, caches the structured telemetry, and surfaces it via CLI/TUI (flags, overlay, or dedicated command).", "status": "done"},
    {"id": "T028", "description": "Teach `hyperion run`/`worker` to emit periodic progress summaries (applied/failed counts, lease deltas, queue depth) so headless runs report steady-state health before the TUI launches.", "status": "done"},
    {"id": "T029", "description": "Extend the CLI/TUI guidance to describe refresh/filter controls, throughput expectations, and live worker counts/latency trends so operators have consistent UX cues when consuming the metrics.", "status": "done"},
    {"id": "T030", "description": "Capture the new telemetry and progress behavior in README/HARDENING/SCHEMAS so downstream contributors know how to rerun or interpret the signals.", "status": "done"},
    {"id": "T031", "description": "Queue telemetry API plus a CLI hook (e.g., `hyperion queue-metrics --format json`) exposing throughput, apply latency, and lease contention.", "status": "done"},
    {"id": "T032", "description": "Periodic progress output for `hyperion run`/`worker` commands that reports counts and queue depth in a predictable, machine-readable format.", "status": "done"},
    {"id": "T033", "description": "TUI guidance overlay/panel describing filters, refresh rates, metrics, and queue-health expectations.", "status": "done"},
    {"id": "T034", "description": "Documentation updates in README/HARDENING/SCHEMAS describing the new telemetry and UX behavior.", "status": "done"}
  ]
}
